// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class Initialized extends EthereumEvent {
  get params(): Initialized__Params {
    return new Initialized__Params(this);
  }
}

export class Initialized__Params {
  _event: Initialized;

  constructor(event: Initialized) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get staker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get counterparty(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get ratio(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get ratioType(): i32 {
    return this._event.parameters[4].value.toI32();
  }

  get countdownLength(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get metadata(): Bytes {
    return this._event.parameters[6].value.toBytes();
  }
}

export class OperatorUpdated extends EthereumEvent {
  get params(): OperatorUpdated__Params {
    return new OperatorUpdated__Params(this);
  }
}

export class OperatorUpdated__Params {
  _event: OperatorUpdated;

  constructor(event: OperatorUpdated) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get status(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class MetadataSet extends EthereumEvent {
  get params(): MetadataSet__Params {
    return new MetadataSet__Params(this);
  }
}

export class MetadataSet__Params {
  _event: MetadataSet;

  constructor(event: MetadataSet) {
    this._event = event;
  }

  get metadata(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class RatioSet extends EthereumEvent {
  get params(): RatioSet__Params {
    return new RatioSet__Params(this);
  }
}

export class RatioSet__Params {
  _event: RatioSet;

  constructor(event: RatioSet) {
    this._event = event;
  }

  get staker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get ratio(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get ratioType(): i32 {
    return this._event.parameters[2].value.toI32();
  }
}

export class Griefed extends EthereumEvent {
  get params(): Griefed__Params {
    return new Griefed__Params(this);
  }
}

export class Griefed__Params {
  _event: Griefed;

  constructor(event: Griefed) {
    this._event = event;
  }

  get punisher(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get staker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get punishment(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get cost(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get message(): Bytes {
    return this._event.parameters[4].value.toBytes();
  }
}

export class StakeAdded extends EthereumEvent {
  get params(): StakeAdded__Params {
    return new StakeAdded__Params(this);
  }
}

export class StakeAdded__Params {
  _event: StakeAdded;

  constructor(event: StakeAdded) {
    this._event = event;
  }

  get staker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get funder(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get newStake(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class StakeTaken extends EthereumEvent {
  get params(): StakeTaken__Params {
    return new StakeTaken__Params(this);
  }
}

export class StakeTaken__Params {
  _event: StakeTaken;

  constructor(event: StakeTaken) {
    this._event = event;
  }

  get staker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get newStake(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class StakeBurned extends EthereumEvent {
  get params(): StakeBurned__Params {
    return new StakeBurned__Params(this);
  }
}

export class StakeBurned__Params {
  _event: StakeBurned;

  constructor(event: StakeBurned) {
    this._event = event;
  }

  get staker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get newStake(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class LengthSet extends EthereumEvent {
  get params(): LengthSet__Params {
    return new LengthSet__Params(this);
  }
}

export class LengthSet__Params {
  _event: LengthSet;

  constructor(event: LengthSet) {
    this._event = event;
  }

  get length(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class DeadlineSet extends EthereumEvent {
  get params(): DeadlineSet__Params {
    return new DeadlineSet__Params(this);
  }
}

export class DeadlineSet__Params {
  _event: DeadlineSet;

  constructor(event: DeadlineSet) {
    this._event = event;
  }

  get deadline(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class CountdownGriefing__getRatioResult {
  value0: BigInt;
  value1: i32;

  constructor(value0: BigInt, value1: i32) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromUnsignedBigInt(this.value0));
    map.set("value1", EthereumValue.fromI32(this.value1));
    return map;
  }
}

export class CountdownGriefing extends SmartContract {
  static bind(address: Address): CountdownGriefing {
    return new CountdownGriefing("CountdownGriefing", address);
  }

  getCreator(): Address {
    let result = super.call("getCreator", []);

    return result[0].toAddress();
  }

  try_getCreator(): CallResult<Address> {
    let result = super.tryCall("getCreator", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  getToken(): Address {
    let result = super.call("getToken", []);

    return result[0].toAddress();
  }

  try_getToken(): CallResult<Address> {
    let result = super.tryCall("getToken", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  isActiveOperator(caller: Address): boolean {
    let result = super.call("isActiveOperator", [
      EthereumValue.fromAddress(caller)
    ]);

    return result[0].toBoolean();
  }

  try_isActiveOperator(caller: Address): CallResult<boolean> {
    let result = super.tryCall("isActiveOperator", [
      EthereumValue.fromAddress(caller)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  getCost(ratio: BigInt, punishment: BigInt, ratioType: i32): BigInt {
    let result = super.call("getCost", [
      EthereumValue.fromUnsignedBigInt(ratio),
      EthereumValue.fromUnsignedBigInt(punishment),
      EthereumValue.fromI32(ratioType)
    ]);

    return result[0].toBigInt();
  }

  try_getCost(
    ratio: BigInt,
    punishment: BigInt,
    ratioType: i32
  ): CallResult<BigInt> {
    let result = super.tryCall("getCost", [
      EthereumValue.fromUnsignedBigInt(ratio),
      EthereumValue.fromUnsignedBigInt(punishment),
      EthereumValue.fromI32(ratioType)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getPunishment(ratio: BigInt, cost: BigInt, ratioType: i32): BigInt {
    let result = super.call("getPunishment", [
      EthereumValue.fromUnsignedBigInt(ratio),
      EthereumValue.fromUnsignedBigInt(cost),
      EthereumValue.fromI32(ratioType)
    ]);

    return result[0].toBigInt();
  }

  try_getPunishment(
    ratio: BigInt,
    cost: BigInt,
    ratioType: i32
  ): CallResult<BigInt> {
    let result = super.tryCall("getPunishment", [
      EthereumValue.fromUnsignedBigInt(ratio),
      EthereumValue.fromUnsignedBigInt(cost),
      EthereumValue.fromI32(ratioType)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getDeadline(): BigInt {
    let result = super.call("getDeadline", []);

    return result[0].toBigInt();
  }

  try_getDeadline(): CallResult<BigInt> {
    let result = super.tryCall("getDeadline", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  isOperator(caller: Address): boolean {
    let result = super.call("isOperator", [EthereumValue.fromAddress(caller)]);

    return result[0].toBoolean();
  }

  try_isOperator(caller: Address): CallResult<boolean> {
    let result = super.tryCall("isOperator", [
      EthereumValue.fromAddress(caller)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  getRatio(staker: Address): CountdownGriefing__getRatioResult {
    let result = super.call("getRatio", [EthereumValue.fromAddress(staker)]);

    return new CountdownGriefing__getRatioResult(
      result[0].toBigInt(),
      result[1].toI32()
    );
  }

  try_getRatio(staker: Address): CallResult<CountdownGriefing__getRatioResult> {
    let result = super.tryCall("getRatio", [EthereumValue.fromAddress(staker)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new CountdownGriefing__getRatioResult(
        value[0].toBigInt(),
        value[1].toI32()
      )
    );
  }

  isAfterDeadline(): boolean {
    let result = super.call("isAfterDeadline", []);

    return result[0].toBoolean();
  }

  try_isAfterDeadline(): CallResult<boolean> {
    let result = super.tryCall("isAfterDeadline", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  getStake(staker: Address): BigInt {
    let result = super.call("getStake", [EthereumValue.fromAddress(staker)]);

    return result[0].toBigInt();
  }

  try_getStake(staker: Address): CallResult<BigInt> {
    let result = super.tryCall("getStake", [EthereumValue.fromAddress(staker)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getFactory(): Address {
    let result = super.call("getFactory", []);

    return result[0].toAddress();
  }

  try_getFactory(): CallResult<Address> {
    let result = super.tryCall("getFactory", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  hasActiveOperator(): boolean {
    let result = super.call("hasActiveOperator", []);

    return result[0].toBoolean();
  }

  try_hasActiveOperator(): CallResult<boolean> {
    let result = super.tryCall("hasActiveOperator", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isOver(): boolean {
    let result = super.call("isOver", []);

    return result[0].toBoolean();
  }

  try_isOver(): CallResult<boolean> {
    let result = super.tryCall("isOver", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  getLength(): BigInt {
    let result = super.call("getLength", []);

    return result[0].toBigInt();
  }

  try_getLength(): CallResult<BigInt> {
    let result = super.tryCall("getLength", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  timeRemaining(): BigInt {
    let result = super.call("timeRemaining", []);

    return result[0].toBigInt();
  }

  try_timeRemaining(): CallResult<BigInt> {
    let result = super.tryCall("timeRemaining", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getOperator(): Address {
    let result = super.call("getOperator", []);

    return result[0].toAddress();
  }

  try_getOperator(): CallResult<Address> {
    let result = super.tryCall("getOperator", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  isCreator(caller: Address): boolean {
    let result = super.call("isCreator", [EthereumValue.fromAddress(caller)]);

    return result[0].toBoolean();
  }

  try_isCreator(caller: Address): CallResult<boolean> {
    let result = super.tryCall("isCreator", [
      EthereumValue.fromAddress(caller)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  punish(currentStake: BigInt, punishment: BigInt, message: Bytes): BigInt {
    let result = super.call("punish", [
      EthereumValue.fromUnsignedBigInt(currentStake),
      EthereumValue.fromUnsignedBigInt(punishment),
      EthereumValue.fromBytes(message)
    ]);

    return result[0].toBigInt();
  }

  try_punish(
    currentStake: BigInt,
    punishment: BigInt,
    message: Bytes
  ): CallResult<BigInt> {
    let result = super.tryCall("punish", [
      EthereumValue.fromUnsignedBigInt(currentStake),
      EthereumValue.fromUnsignedBigInt(punishment),
      EthereumValue.fromBytes(message)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  startCountdown(): BigInt {
    let result = super.call("startCountdown", []);

    return result[0].toBigInt();
  }

  try_startCountdown(): CallResult<BigInt> {
    let result = super.tryCall("startCountdown", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  retrieveStake(recipient: Address): BigInt {
    let result = super.call("retrieveStake", [
      EthereumValue.fromAddress(recipient)
    ]);

    return result[0].toBigInt();
  }

  try_retrieveStake(recipient: Address): CallResult<BigInt> {
    let result = super.tryCall("retrieveStake", [
      EthereumValue.fromAddress(recipient)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  isStaker(caller: Address): boolean {
    let result = super.call("isStaker", [EthereumValue.fromAddress(caller)]);

    return result[0].toBoolean();
  }

  try_isStaker(caller: Address): CallResult<boolean> {
    let result = super.tryCall("isStaker", [EthereumValue.fromAddress(caller)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  isCounterparty(caller: Address): boolean {
    let result = super.call("isCounterparty", [
      EthereumValue.fromAddress(caller)
    ]);

    return result[0].toBoolean();
  }

  try_isCounterparty(caller: Address): CallResult<boolean> {
    let result = super.tryCall("isCounterparty", [
      EthereumValue.fromAddress(caller)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }
}

export class InitializeCall extends EthereumCall {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get staker(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get counterparty(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get ratio(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get ratioType(): i32 {
    return this._call.inputValues[4].value.toI32();
  }

  get countdownLength(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get metadata(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class SetMetadataCall extends EthereumCall {
  get inputs(): SetMetadataCall__Inputs {
    return new SetMetadataCall__Inputs(this);
  }

  get outputs(): SetMetadataCall__Outputs {
    return new SetMetadataCall__Outputs(this);
  }
}

export class SetMetadataCall__Inputs {
  _call: SetMetadataCall;

  constructor(call: SetMetadataCall) {
    this._call = call;
  }

  get metadata(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class SetMetadataCall__Outputs {
  _call: SetMetadataCall;

  constructor(call: SetMetadataCall) {
    this._call = call;
  }
}

export class IncreaseStakeCall extends EthereumCall {
  get inputs(): IncreaseStakeCall__Inputs {
    return new IncreaseStakeCall__Inputs(this);
  }

  get outputs(): IncreaseStakeCall__Outputs {
    return new IncreaseStakeCall__Outputs(this);
  }
}

export class IncreaseStakeCall__Inputs {
  _call: IncreaseStakeCall;

  constructor(call: IncreaseStakeCall) {
    this._call = call;
  }

  get currentStake(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amountToAdd(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class IncreaseStakeCall__Outputs {
  _call: IncreaseStakeCall;

  constructor(call: IncreaseStakeCall) {
    this._call = call;
  }
}

export class RewardCall extends EthereumCall {
  get inputs(): RewardCall__Inputs {
    return new RewardCall__Inputs(this);
  }

  get outputs(): RewardCall__Outputs {
    return new RewardCall__Outputs(this);
  }
}

export class RewardCall__Inputs {
  _call: RewardCall;

  constructor(call: RewardCall) {
    this._call = call;
  }

  get currentStake(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amountToAdd(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RewardCall__Outputs {
  _call: RewardCall;

  constructor(call: RewardCall) {
    this._call = call;
  }
}

export class PunishCall extends EthereumCall {
  get inputs(): PunishCall__Inputs {
    return new PunishCall__Inputs(this);
  }

  get outputs(): PunishCall__Outputs {
    return new PunishCall__Outputs(this);
  }
}

export class PunishCall__Inputs {
  _call: PunishCall;

  constructor(call: PunishCall) {
    this._call = call;
  }

  get currentStake(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get punishment(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get message(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class PunishCall__Outputs {
  _call: PunishCall;

  constructor(call: PunishCall) {
    this._call = call;
  }

  get cost(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ReleaseStakeCall extends EthereumCall {
  get inputs(): ReleaseStakeCall__Inputs {
    return new ReleaseStakeCall__Inputs(this);
  }

  get outputs(): ReleaseStakeCall__Outputs {
    return new ReleaseStakeCall__Outputs(this);
  }
}

export class ReleaseStakeCall__Inputs {
  _call: ReleaseStakeCall;

  constructor(call: ReleaseStakeCall) {
    this._call = call;
  }

  get currentStake(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amountToRelease(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ReleaseStakeCall__Outputs {
  _call: ReleaseStakeCall;

  constructor(call: ReleaseStakeCall) {
    this._call = call;
  }
}

export class StartCountdownCall extends EthereumCall {
  get inputs(): StartCountdownCall__Inputs {
    return new StartCountdownCall__Inputs(this);
  }

  get outputs(): StartCountdownCall__Outputs {
    return new StartCountdownCall__Outputs(this);
  }
}

export class StartCountdownCall__Inputs {
  _call: StartCountdownCall;

  constructor(call: StartCountdownCall) {
    this._call = call;
  }
}

export class StartCountdownCall__Outputs {
  _call: StartCountdownCall;

  constructor(call: StartCountdownCall) {
    this._call = call;
  }

  get deadline(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RetrieveStakeCall extends EthereumCall {
  get inputs(): RetrieveStakeCall__Inputs {
    return new RetrieveStakeCall__Inputs(this);
  }

  get outputs(): RetrieveStakeCall__Outputs {
    return new RetrieveStakeCall__Outputs(this);
  }
}

export class RetrieveStakeCall__Inputs {
  _call: RetrieveStakeCall;

  constructor(call: RetrieveStakeCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RetrieveStakeCall__Outputs {
  _call: RetrieveStakeCall;

  constructor(call: RetrieveStakeCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TransferOperatorCall extends EthereumCall {
  get inputs(): TransferOperatorCall__Inputs {
    return new TransferOperatorCall__Inputs(this);
  }

  get outputs(): TransferOperatorCall__Outputs {
    return new TransferOperatorCall__Outputs(this);
  }
}

export class TransferOperatorCall__Inputs {
  _call: TransferOperatorCall;

  constructor(call: TransferOperatorCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOperatorCall__Outputs {
  _call: TransferOperatorCall;

  constructor(call: TransferOperatorCall) {
    this._call = call;
  }
}

export class RenounceOperatorCall extends EthereumCall {
  get inputs(): RenounceOperatorCall__Inputs {
    return new RenounceOperatorCall__Inputs(this);
  }

  get outputs(): RenounceOperatorCall__Outputs {
    return new RenounceOperatorCall__Outputs(this);
  }
}

export class RenounceOperatorCall__Inputs {
  _call: RenounceOperatorCall;

  constructor(call: RenounceOperatorCall) {
    this._call = call;
  }
}

export class RenounceOperatorCall__Outputs {
  _call: RenounceOperatorCall;

  constructor(call: RenounceOperatorCall) {
    this._call = call;
  }
}
