{
  "contractName": "TokenManager",
  "abi": [
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "enum TokenManager.Tokens",
          "name": "tokenID",
          "type": "uint8"
        }
      ],
      "name": "getTokenAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "bytecode": "0x608060405234801561001057600080fd5b50610175806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80635ad3f91814610030575b600080fd5b61005f6004803603602081101561004657600080fd5b81019080803560ff1690602001909291905050506100a1565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b60006002808111156100af57fe5b8260028111156100bb57fe5b14156100d0576100c9610108565b9050610103565b600160028111156100dd57fe5b8260028111156100e957fe5b14156100fe576100f7610124565b9050610103565b600090505b919050565b6000736b175474e89094c44da98b954eedeac495271d0f905090565b6000731776e1f26f98b1a5df9cd347953a26dd3cb4667190509056fea265627a7a723158209238145aefb0a86a927ef5722c70c8b78c12d91e627d99476d9b81ff246b553064736f6c634300050d0032",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80635ad3f91814610030575b600080fd5b61005f6004803603602081101561004657600080fd5b81019080803560ff1690602001909291905050506100a1565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b60006002808111156100af57fe5b8260028111156100bb57fe5b14156100d0576100c9610108565b9050610103565b600160028111156100dd57fe5b8260028111156100e957fe5b14156100fe576100f7610124565b9050610103565b600090505b919050565b6000736b175474e89094c44da98b954eedeac495271d0f905090565b6000731776e1f26f98b1a5df9cd347953a26dd3cb4667190509056fea265627a7a723158209238145aefb0a86a927ef5722c70c8b78c12d91e627d99476d9b81ff246b553064736f6c634300050d0032",
  "sourceMap": "302:4635:25:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;302:4635:25;;;;;;;",
  "deployedSourceMap": "302:4635:25:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;302:4635:25;;;;;;;;;;;;;;;;;;;555:280;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;555:280:25;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;617:20;664:10;653:21;;;;;;;;:7;:21;;;;;;;;;649:71;;;695:25;:23;:25::i;:::-;688:32;;;;649:71;745:10;734:21;;;;;;;;:7;:21;;;;;;;;;730:71;;;776:25;:23;:25::i;:::-;769:32;;;;730:71;826:1;811:17;;555:280;;;;:::o;2880:99:9:-;2930:13;526:42;2955:17;;2880:99;:::o;1501::10:-;1551:13;565:42;1576:17;;1501:99;:::o",
  "source": "pragma solidity ^0.5.13;\n\nimport \"./BurnDAI.sol\";\n\n/// @title TokenManager\n/// @author Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This module provides a standard interface for interacting with supported ERC20 tokens.\ncontract TokenManager is BurnDAI {\n\n    enum Tokens { NaN, NMR, DAI }\n\n    /// @notice Get the address of the given token ID.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return tokenAddress address of the ERC20 token.\n    function getTokenAddress(Tokens tokenID) public pure returns (address tokenAddress) {\n        if (tokenID == Tokens.DAI)\n            return BurnDAI.getTokenAddress();\n        if (tokenID == Tokens.NMR)\n            return BurnNMR.getTokenAddress();\n        return address(0);\n    }\n\n    modifier onlyValidTokenID(Tokens tokenID) {\n        require(isValidTokenID(tokenID), 'invalid tokenID');\n        _;\n    }\n\n    /// @notice Validate the token ID is a supported token.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return validity bool true if the token is supported.\n    function isValidTokenID(Tokens tokenID) internal pure returns (bool validity) {\n        return tokenID == Tokens.NMR || tokenID == Tokens.DAI;\n    }\n\n    /// @notice ERC20 ransfer.\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param to address of the recipient.\n    /// @param value uint256 amount of tokens.\n    function _transfer(Tokens tokenID, address to, uint256 value) internal onlyValidTokenID(tokenID) {\n        require(IERC20(getTokenAddress(tokenID)).transfer(to, value), 'token transfer failed');\n    }\n\n    /// @notice ERC20 TransferFrom\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param from address to spend from.\n    /// @param to address of the recipient.\n    /// @param value uint256 amount of tokens.\n    function _transferFrom(Tokens tokenID, address from, address to, uint256 value) internal onlyValidTokenID(tokenID) {\n        require(IERC20(getTokenAddress(tokenID)).transferFrom(from, to, value), 'token transfer failed');\n    }\n\n    /// @notice ERC20 Burn\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param value uint256 amount of tokens.\n    function _burn(Tokens tokenID, uint256 value) internal onlyValidTokenID(tokenID) {\n        if (tokenID == Tokens.DAI) {\n            BurnDAI._burn(value);\n        } else if (tokenID == Tokens.NMR) {\n            BurnNMR._burn(value);\n        }\n    }\n\n    /// @notice ERC20 BurnFrom\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param from address to burn from.\n    /// @param value uint256 amount of tokens.\n    function _burnFrom(Tokens tokenID, address from, uint256 value) internal onlyValidTokenID(tokenID) {\n        if (tokenID == Tokens.DAI) {\n            BurnDAI._burnFrom(from, value);\n        } else if (tokenID == Tokens.NMR) {\n            BurnNMR._burnFrom(from, value);\n        }\n    }\n\n    /// @notice ERC20 Approve\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param spender address of the spender.\n    /// @param value uint256 amount of tokens.\n    function _approve(Tokens tokenID, address spender, uint256 value) internal onlyValidTokenID(tokenID) {\n        if (tokenID == Tokens.DAI) {\n            require(IERC20(BurnDAI.getTokenAddress()).approve(spender, value), 'token approval failed');\n        } else if (tokenID == Tokens.NMR) {\n            address nmr = BurnNMR.getTokenAddress();\n            uint256 currentAllowance = IERC20(nmr).allowance(msg.sender, spender);\n            require(iNMR(nmr).changeApproval(spender, currentAllowance, value), 'token approval failed');\n        }\n    }\n\n    /// @notice ERC20 TotalSupply\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @return value uint256 amount of tokens.\n    function totalSupply(Tokens tokenID) internal view onlyValidTokenID(tokenID) returns (uint256 value) {\n        return IERC20(getTokenAddress(tokenID)).totalSupply();\n    }\n\n    /// @notice ERC20 BalanceOf\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param who address of the owner.\n    /// @return value uint256 amount of tokens.\n    function balanceOf(Tokens tokenID, address who) internal view onlyValidTokenID(tokenID) returns (uint256 value) {\n        return IERC20(getTokenAddress(tokenID)).balanceOf(who);\n    }\n\n    /// @notice ERC20 Allowance\n    /// @param tokenID TokenManager.Tokens ID of the ERC20 token.\n    /// @param owner address of the owner.\n    /// @param spender address of the spender.\n    /// @return value uint256 amount of tokens.\n    function allowance(Tokens tokenID, address owner, address spender) internal view onlyValidTokenID(tokenID) returns (uint256 value) {\n        return IERC20(getTokenAddress(tokenID)).allowance(owner, spender);\n    }\n}"
  }