{
	"schemaVersion": "2.0.0",
	"contractName": "ProofHash",
	"compilerOutput": {
		"abi": [
			{
				"constant": true,
				"inputs": [],
				"name": "getProofHash",
				"outputs": [
					{
						"internalType": "bytes",
						"name": "proofHash",
						"type": "bytes"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"internalType": "address",
						"name": "caller",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "bytes",
						"name": "proofHash",
						"type": "bytes"
					}
				],
				"name": "ProofHashSet",
				"type": "event"
			}
		],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x608060405234801561001057600080fd5b50610239806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806355e0337314610030575b600080fd5b6100386100ad565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561007257818101518382015260200161005a565b50505050905090810190601f16801561009f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6040805160608181018352600054825260015460ff808216602085015261010090910416928201929092526100e1906100e6565b905090565b6040805160228082526060828101909352829190602082018180388339019050509050826020015160f81b8160008151811061011e57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350826040015160f81b8160018151811061016257fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060005b60208160ff1610156101fd57835160ff8216602081106101b057fe5b1a60f81b828260020160ff16815181106101c657fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600101610194565b509291505056fea265627a7a72315820eb1426e4bc4c026274b94425b673106a6bbe77975cfaf699cea56be6e0757a4264736f6c634300050b0032",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x239 DUP1 PUSH2 0x20 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x2B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x55E03373 EQ PUSH2 0x30 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x38 PUSH2 0xAD JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x20 DUP1 DUP3 MSTORE DUP4 MLOAD DUP2 DUP4 ADD MSTORE DUP4 MLOAD SWAP2 SWAP3 DUP4 SWAP3 SWAP1 DUP4 ADD SWAP2 DUP6 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x72 JUMPI DUP2 DUP2 ADD MLOAD DUP4 DUP3 ADD MSTORE PUSH1 0x20 ADD PUSH2 0x5A JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x9F JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x60 DUP2 DUP2 ADD DUP4 MSTORE PUSH1 0x0 SLOAD DUP3 MSTORE PUSH1 0x1 SLOAD PUSH1 0xFF DUP1 DUP3 AND PUSH1 0x20 DUP6 ADD MSTORE PUSH2 0x100 SWAP1 SWAP2 DIV AND SWAP3 DUP3 ADD SWAP3 SWAP1 SWAP3 MSTORE PUSH2 0xE1 SWAP1 PUSH2 0xE6 JUMP JUMPDEST SWAP1 POP SWAP1 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x22 DUP1 DUP3 MSTORE PUSH1 0x60 DUP3 DUP2 ADD SWAP1 SWAP4 MSTORE DUP3 SWAP2 SWAP1 PUSH1 0x20 DUP3 ADD DUP2 DUP1 CODESIZE DUP4 CODECOPY ADD SWAP1 POP POP SWAP1 POP DUP3 PUSH1 0x20 ADD MLOAD PUSH1 0xF8 SHL DUP2 PUSH1 0x0 DUP2 MLOAD DUP2 LT PUSH2 0x11E JUMPI INVALID JUMPDEST PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP DUP3 PUSH1 0x40 ADD MLOAD PUSH1 0xF8 SHL DUP2 PUSH1 0x1 DUP2 MLOAD DUP2 LT PUSH2 0x162 JUMPI INVALID JUMPDEST PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP PUSH1 0x0 JUMPDEST PUSH1 0x20 DUP2 PUSH1 0xFF AND LT ISZERO PUSH2 0x1FD JUMPI DUP4 MLOAD PUSH1 0xFF DUP3 AND PUSH1 0x20 DUP2 LT PUSH2 0x1B0 JUMPI INVALID JUMPDEST BYTE PUSH1 0xF8 SHL DUP3 DUP3 PUSH1 0x2 ADD PUSH1 0xFF AND DUP2 MLOAD DUP2 LT PUSH2 0x1C6 JUMPI INVALID JUMPDEST PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP PUSH1 0x1 ADD PUSH2 0x194 JUMP JUMPDEST POP SWAP3 SWAP2 POP POP JUMP INVALID LOG2 PUSH6 0x627A7A723158 KECCAK256 0xeb EQ 0x26 0xe4 0xbc 0x4c MUL PUSH3 0x74B944 0x25 0xb6 PUSH20 0x106A6BBE77975CFAF699CEA56BE6E0757A426473 PUSH16 0x6C634300050B00320000000000000000 ",
				"sourceMap": "60:518:25:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;60:518:25;;;;;;;"
			}
		}
	},
	"sources": {
		"modules/ProofHash.sol": {
			"id": 25
		},
		"modules/MultiHashWrapper.sol": {
			"id": 23
		}
	},
	"sourceCodes": {
		"modules/ProofHash.sol": "pragma solidity ^0.5.0;\n\nimport \"./MultiHashWrapper.sol\";\n\n\ncontract ProofHash is MultiHashWrapper {\n\n    MultiHash private _proofHash;\n\n    event ProofHashSet(address caller, bytes proofHash);\n\n    // state functions\n\n    function _setProofHash(bytes memory proofHash) internal {\n        _proofHash = MultiHashWrapper._splitMultiHash(proofHash);\n        emit ProofHashSet(msg.sender, proofHash);\n    }\n\n    // view functions\n\n    function getProofHash() public view returns (bytes memory proofHash) {\n        proofHash = MultiHashWrapper._combineMultiHash(_proofHash);\n    }\n\n}\n",
		"modules/MultiHashWrapper.sol": "pragma solidity ^0.5.0;\n\n\n/**\n * @title MultiHashWrapper\n * @dev Contract that handles multi hash data structures and encoding/decoding\n *   Learn more here: https://github.com/multiformats/multihash\n */\ncontract MultiHashWrapper {\n\n    // bytes32 hash first to fill the first storage slot\n    struct MultiHash {\n        bytes32 hash;\n        uint8 hashFunction;\n        uint8 digestSize;\n    }\n\n    /**\n    * @dev Given a multihash struct, returns the full base58-encoded hash\n    * @param multihash MultiHash struct that has the hashFunction, digestSize and the hash\n    * @return the base58-encoded full hash\n    */\n    function _combineMultiHash(MultiHash memory multihash) internal pure returns (bytes memory) {\n        bytes memory out = new bytes(34);\n\n        out[0] = byte(multihash.hashFunction);\n        out[1] = byte(multihash.digestSize);\n\n        uint8 i;\n        for (i = 0; i < 32; i++) {\n          out[i+2] = multihash.hash[i];\n        }\n\n        return out;\n    }\n\n    /**\n    * @dev Given a base58-encoded  hash, divides into its individual parts and returns a struct\n    * @param source base58-encoded  hash\n    * @return MultiHash that has the hashFunction, digestSize and the hash\n    */\n    function _splitMultiHash(bytes memory source) internal pure returns (MultiHash memory) {\n        require(source.length == 34, \"length of source must be 34\");\n\n        uint8 hashFunction = uint8(source[0]);\n        uint8 digestSize = uint8(source[1]);\n        bytes32 hash;\n\n        assembly {\n          hash := mload(add(source, 34))\n        }\n\n        return (MultiHash({\n          hashFunction: hashFunction,\n          digestSize: digestSize,\n          hash: hash\n        }));\n    }\n}\n"
	},
	"sourceTreeHashHex": "0xa576976ea745aabe4d26bf1054f630b0f9267ca4f9c9f548f638575cf3e675d1",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.5.11+commit.c082d0b4.js",
		"settings": {
			"optimizer": {
				"enabled": true,
				"runs": 999999999
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object"
					]
				}
			},
			"evmVersion": "constantinople",
			"remappings": []
		}
	},
	"networks": {}
}