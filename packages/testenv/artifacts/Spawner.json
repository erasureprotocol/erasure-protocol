{
	"schemaVersion": "2.0.0",
	"contractName": "Spawner",
	"compilerOutput": {
		"abi": [],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x6080604052348015600f57600080fd5b50603e80601d6000396000f3fe6080604052600080fdfea265627a7a723158206ac8056611adb4f8cb4807dd2d89af1f29c3cff88dc2c742d1e93c39b609986a64736f6c634300050b0032",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x3E DUP1 PUSH1 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH6 0x627A7A723158 KECCAK256 PUSH11 0xC8056611ADB4F8CB4807DD 0x2d DUP10 0xaf 0x1f 0x29 0xc3 0xcf 0xf8 DUP14 0xc2 0xc7 TIMESTAMP 0xd1 0xe9 EXTCODECOPY CODECOPY 0xb6 MULMOD SWAP9 PUSH11 0x64736F6C634300050B0032 ",
				"sourceMap": "1416:8351:28:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;1416:8351:28;;;;;;;"
			}
		}
	},
	"sources": {
		"modules/Spawner.sol": {
			"id": 28
		}
	},
	"sourceCodes": {
		"modules/Spawner.sol": "pragma solidity ^0.5.0;\n\n\n/**\n * @title Spawn\n * @author 0age\n * @notice This contract provides creation code that is used by Spawner in order\n * to initialize and deploy eip-1167 minimal proxies for a given logic contract.\n */\ncontract Spawn {\n  constructor(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) public payable {\n    // delegatecall into the logic contract to perform initialization.\n    (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n    if (!ok) {\n      // pass along failure message from delegatecall and revert.\n      assembly {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    // place eip-1167 runtime code in memory.\n    bytes memory runtimeCode = abi.encodePacked(\n      bytes10(0x363d3d373d3d3d363d73),\n      logicContract,\n      bytes15(0x5af43d82803e903d91602b57fd5bf3)\n    );\n\n    // return eip-1167 code to write it to spawned contract runtime.\n    assembly {\n      return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n    }\n  }\n}\n\n/**\n * @title Spawner\n * @author 0age\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\n * point to existing logic contracts. The logic contracts need to have an\n * intitializer function that should only callable when no contract exists at\n * their current address (i.e. it is being `DELEGATECALL`ed from a constructor).\n */\ncontract Spawner {\n  /**\n   * @notice Internal function for spawning an eip-1167 minimal proxy using\n   * `CREATE2`.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawn(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get salt to use during deployment using the supplied initialization code.\n    (bytes32 salt, address target) = _getSaltAndTarget(initCode);\n\n    // spawn the contract using `CREATE2`.\n    spawnedContract = _spawnCreate2(initCode, salt, target);\n  }\n\n  /**\n   * @notice Internal function for spawning an eip-1167 minimal proxy using\n   * `CREATE2`.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @param salt bytes32 A random salt\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawnSalty(\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal returns (address spawnedContract) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    address target = _computeTargetAddress(logicContract, initializationCalldata, salt);\n\n    uint256 codeSize;\n    assembly { codeSize := extcodesize(target) }\n    require(codeSize == 0, \"contract already deployed with supplied salt\");\n\n    // spawn the contract using `CREATE2`.\n    spawnedContract = _spawnCreate2(initCode, salt, target);\n  }\n\n  /**\n   * @notice Internal view function for finding the address of the next standard\n   * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n   * and initialization calldata payload.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @return The address of the next spawned minimal proxy contract with the\n   * given parameters.\n   */\n  function _getNextAddress(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal view returns (address target) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get target address using the constructed initialization code.\n    (, target) = _getSaltAndTarget(initCode);\n  }\n\n  /**\n   * @notice Internal view function for finding the address of the next standard\n   * eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n   * salt, and initialization calldata payload.\n   * @param initCodeHash bytes32 The encoded hash of initCode\n   * @param salt bytes32 A random salt\n   * @return The address of the next spawned minimal proxy contract with the\n   * given parameters.\n   */\n  function _computeTargetAddress(\n    bytes32 initCodeHash,\n    bytes32 salt\n  ) internal view returns (address target) {\n    target = address(    // derive the target deployment address.\n      uint160(                   // downcast to match the address type.\n        uint256(                 // cast to uint to truncate upper digits.\n          keccak256(             // compute CREATE2 hash using 4 inputs.\n            abi.encodePacked(    // pack all inputs to the hash together.\n              bytes1(0xff),      // pass in the control character.\n              address(this),     // pass in the address of this contract.\n              salt,              // pass in the salt from above.\n              initCodeHash       // pass in hash of contract creation code.\n            )\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * @notice Internal view function for finding the address of the next standard\n   * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n   * and initialization calldata payload.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @param salt bytes32 A random salt\n   * @return The address of the next spawned minimal proxy contract with the\n   * given parameters.\n   */\n  function _computeTargetAddress(\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal view returns (address target) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n    // get the keccak256 hash of the init code for address derivation.\n    bytes32 initCodeHash = keccak256(initCode);\n\n    target = _computeTargetAddress(initCodeHash, salt);\n  }\n\n  /**\n   * @notice Private function for spawning a compact eip-1167 minimal proxy\n   * using `CREATE2`. Provides logic that is reused by internal functions. A\n   * salt will also be chosen based on the calling address and a computed nonce\n   * that prevents deployments to existing addresses.\n   * @param initCode bytes The contract creation code.\n   * @param salt bytes32 A random salt\n   * @param target address The expected address of the new contract\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawnCreate2(\n    bytes memory initCode,\n    bytes32 salt,\n    address target\n  ) private returns (address spawnedContract) {\n    assembly {\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      spawnedContract := create2(             // call `CREATE2` w/ 4 arguments.\n        callvalue,                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n\n      // pass along failure message from failed contract deployment and revert.\n      if iszero(spawnedContract) {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    require(spawnedContract == target, \"attempted deployment to unexpected address\");\n  }\n\n  /**\n   * @notice Private function for determining the salt and the target deployment\n   * address for the next spawned contract (using create2) based on the contract\n   * creation code.\n   */\n  function _getSaltAndTarget(\n    bytes memory initCode\n  ) private view returns (bytes32 salt, address target) {\n    // get the keccak256 hash of the init code for address derivation.\n    bytes32 initCodeHash = keccak256(initCode);\n\n    // set the initial nonce to be provided when constructing the salt.\n    uint256 nonce = 0;\n\n    // declare variable for code size of derived address.\n    uint256 codeSize;\n\n    while (true) {\n      // derive `CREATE2` salt using `msg.sender` and nonce.\n      salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n      target = _computeTargetAddress(initCodeHash, salt);\n\n      // determine if a contract is already deployed to the target address.\n      assembly { codeSize := extcodesize(target) }\n\n      // exit the loop if no contract is deployed to the target address.\n      if (codeSize == 0) {\n        break;\n      }\n\n      // otherwise, increment the nonce and derive a new salt.\n      nonce++;\n    }\n  }\n}\n"
	},
	"sourceTreeHashHex": "0xa3fe26e9654f68cb194f05950e08520fb5eb37b75a8632c8900c15c1e35e88b5",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.5.11+commit.c082d0b4.js",
		"settings": {
			"optimizer": {
				"enabled": true,
				"runs": 999999999
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object"
					]
				}
			},
			"evmVersion": "constantinople",
			"remappings": []
		}
	},
	"networks": {}
}