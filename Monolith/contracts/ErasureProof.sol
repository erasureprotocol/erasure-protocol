pragma solidity 0.5.7;

import "./helpers/openzeppelin-solidity/cryptography/ECDSA.sol";


contract ErasureProof {

    using ECDSA for bytes32;

    event ProofCreation(bytes32 proofHash, address indexed owner, uint64 timestamp, bytes32 prevHash);

    struct Proof {
        address owner;      // Owner of the prediction chain
        uint64 timestamp;   // UNIX timestamp of creation time of the proof
        bytes32 prevHash;   // Hash of the previous proof
        bytes32 nextHash;   // Hash of the next proof
    }

    // Array of all proof hashes
    bytes32[] private _hashes;

    // Mapping of unique nonces to proof objects
    mapping (bytes32 => Proof) private _hashToProof;


    /////////////
    // Setters //
    /////////////

    /**
     * @dev Create proof object and add it to the appropriate prediction chain
     * @param owner Address of the owner of the prediction chain
     * @param prevHash Keccak256 hash of the previous proof
     * @param dataHash Keccak256 hash of the data
     * @param sig Signature generated by the owner to authenticate and confirm proofHash = keccak256(owner,prevHash,dataHash)
     */
    function createProof(address owner, bytes32 prevHash, bytes32 dataHash, bytes calldata sig) external returns (bytes32 proofHash) {
        proofHash = getProofHash(owner, prevHash, dataHash);

        require(_hashToProof[proofHash].owner == address(0), "proofHash not unique");
        require(owner == getRecover(proofHash, sig), "incorrect signature");
        require(owner != address(0), "invalid signature");

        Proof memory proof;
        proof.owner = owner;
        proof.timestamp = uint64(now);

        if (prevHash != bytes32(0)) {
            proof.prevHash = prevHash;
            require(_hashToProof[prevHash].nextHash == bytes32(0), "prevHash not head");
            require(_hashToProof[prevHash].owner == owner, "wrong owner");
            _hashToProof[prevHash].nextHash = proofHash;
        }

        _hashToProof[proofHash] = proof;
        _hashes.push(proofHash);

        emit ProofCreation(proofHash, owner, proof.timestamp, prevHash);
    }

    /////////////
    // Getters //
    /////////////

    function getProofHash(address owner, bytes32 prevHash, bytes32 dataHash) public pure returns (bytes32 proofHash) {
        return keccak256(abi.encode(owner, prevHash, dataHash));
    }

    function getRecover(bytes32 proofHash, bytes memory sig) public pure returns (address owner) {
        return proofHash.toEthSignedMessageHash().recover(sig);
    }

    /**
     * @dev View method to return the proof object for the corresponding hash
     * @param proofHash unique identifier of the proof
     */
    function getProof(bytes32 proofHash) external view returns (address owner, uint64 timestamp, bytes32 prevHash, bytes32 nextHash) {
        Proof memory proof = _hashToProof[proofHash];
        return (proof.owner, proof.timestamp, proof.prevHash, proof.nextHash);
    }

    function getHashes() external view returns (bytes32[] memory hashes) {
        return (_hashes);
    }
}
